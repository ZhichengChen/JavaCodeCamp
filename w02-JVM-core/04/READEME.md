# 串行/并行/CMS/G1垃圾回收器例子以及不同 GC 和堆内存特点分析总结

## 并行 GC

串行 GC 对年轻代使用 mark-copy 算法，对老年代使用 mark-sweep-compace 算法。

两者都是单线程的垃圾收集器，不能进行并行处理。不能充分利用多核 CPU。适合几百 MB 的堆内存 JVM。

## 并行 GC

串行 GC 对年轻代使用 mark-copy 算法，对老年代使用 mark-sweep-compace 算法。

GC 期间所有CPU 内核都在并行清理垃圾，线程数默认为 CPU 核心数。

适用于多核服务器。

JDK 678 默认的 GC 是并行 GC，JDK 9 及以上默认的 GC 为 G1。

## CMS GC

对年轻代使用并行 mark-copy 算法，对老年代使用并发 mark-sweep 算法。

如果某个系统支持两个或者多个动作（Action）**同时存在**，那么这个系统就是一个**并发系统**。如果某个系统支持两个或者多个动作**同时执行**，那么这个系统就是一个**并行系统**。

CMS 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿。不对老年代进行整理，而是使用空闲列表来管理内存空间的回收。在 mark-sweep 阶段的大部分工作和应用线程一起并发执行。

默认 CMS 使用的并发线程等于 CPU 核心数的 1/4。

1. Initial Mark
   1. 标记所有的根对象
   2. 标记根对象直接引用的对象
   3. 标记被年轻代中所有存活的对象所引用的对象
2. Concurrent Mark
   1. 遍历老年代，标记所有的存活对象
3. Concurrent Preclean
   1. 并发预清理
   2. 通过 Card 方式将引用关系发生变化的区域标记为脏区
4. Final Mark
   1. 完成老年代所有存活对象的标记
5. Concurrent Sweep
   1. 删除不在使用的对象，回收它们占用的内存空间
6. Concurrent Reset
   1. 重置内部数据

CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执行的同时，并不需要暂停应用线程。

CMS 因为未压缩存在老年代碎片化的问题，在某些情况下特别是内存较大的情况下会造成不可预测的暂停时间。

## G1 GC

G1 GC 的设计目标是将 STW 停顿的时间和分布，变成可预期和可配置的。G1 GC 堆不在分成年轻代和老年代，而是划分为多个（通常是 2048 个）小块。每个块可能一会被定义为 Eden 区，一会定义成 Survivor 区或者 Old 区。这样可以每次只处理一部分内存块，每次 GC 暂停都会收集所有的年轻代的内存块，但一般只包含部分老年代内存块。在并发阶段估算每个小堆块存活的对象的总数。垃圾最多的小块会被优先收集。

某些情况下 G1 触发了 Full GC，G1 会退化为串行 GC 来完成垃圾的清理工作，它仅仅使用单线程来完成 GC 工作。

1. 并发模式失败
   1. G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时 G1 会放弃标记周期
   2. 解决办法，增加推大小，或调整周期
2. 晋升失败
   1. 没有足够的内存供存活对象或晋升对象使用
      1. 解决办法，增加 -XX:Initialting
3. 巨型对象分配失败

