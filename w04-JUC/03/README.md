# 列举常用的并发操作 API 和工具类，简单分析其使用场景和优优缺点

## 并发操作 API

### 锁操作 API

#### ReentrantLock

| 方法                            | 说明                          |
| ------------------------------- | ------------------------------|
| lock():void                     | 加锁                          |
| unlock():void                   | 解锁                          |
| lockInterruptibly():void        | 加锁（可中断）                 |
| tryLock():boolean               | 加锁（返回是否成功）           |
| tryLock(long, TimeUnit):boolean | 在指定时间内加锁（返回是否成功）|
| isLocked():boolean              | 判断是否被锁定                 |

##### 应用场景


##### 优缺点

优点：相比于 synchronized，可以中断，可以返回是否加锁成功，更灵活
缺点：



#### ReentrantReadWriteLock

| 方法                            | 说明                          |
| ------------------------------- | ------------------------------|
| writeLock():writeLock           | 加写锁                         |
| readLock():readLock             | 加读锁                         |

##### 应用场景

对应读多写少的场景，可以读写锁分离，读共享，写排他

##### 优缺点

优点：提高效率
缺点：

#### Condition

| 方法                            | 说明                              |
| ------------------------------- | ---------------------------------|
| await():void                    | 当前线程进入等待直到 signal 或中断 |
| signal():void                   | 唤醒等待的线程                    |

##### 应用场景

可以根据不同的条件创建多个锁，粒度更细

##### 优缺点

优点：
缺点：

#### LockSupport

| 方法                            | 说明                              |
| ------------------------------- | ---------------------------------|
| park():void                     | 暂停当前线程重新调度              |
| unpark():void                   | 接触 park 线程的阻塞状态          |

##### 应用场景

由于 park 后该线程还可能被重新调度到，无法保证调用后的状态

##### 优缺点

优点：
缺点：

### 原子类操作 API

#### AtomicInteger/AtomicLong

| 方法                            | 说明                              |
| ------------------------------- | ---------------------------------|
| incrementAndGet():int/long      | 加 1 然后返回加 1 之后的值         |
| get():int/long                  | 返回当前的值                      |

##### 应用场景

使用 CAS，避免锁竞争带来的开销

##### 优缺点

优点：
缺点：

#### LongAdder

| 方法                            | 说明                              |
| ------------------------------- | ---------------------------------|
| increment():void                | 加 1                             |
| sum():long                      | 返回当前的和                      |

##### 应用场景

对于多线程同时递增的场景，使用分段机制，减少 CAS 操作的空操作对 CPU 的消耗

##### 优缺点

优点：
缺点：

### 线程池操作 API

#### Executors

| 方法                                       | 说明                              |
| ------------------------------------------ | ---------------------------------|
| newFixedThreadPool(int):ExecutorService    | 创建一个固定线程数量的线程池       |
| newSingleThreadExecutor():ExecutorService  | 创建单个线程的线程池              |
| newCachedThreadPool():ExecutorService      | 创建可以复用之前创建线程的线程池   |
| newScheduledThreadPool():ExecutorService   | 创建一个可以周期/延迟运行的线程池  |

##### 应用场景

JDK 自带线程池，通过 Executors 工具方法可以方便创建各个场景的线程池，省去了繁杂的配置项

##### 优缺点

优点：
缺点：


## 并发工具类

### CountDownLatch

##### 应用场景

多个线程执行完毕后一起执行某操作

##### 优缺点

优点：
缺点：

### CyclicBarrier

##### 应用场景

多个线程 ready 后一起执行。不是基于 AQS 实现的。


##### 优缺点

优点：
缺点：

### Samaphore

##### 应用场景

同一时间只允许指定数量的线程同时执行。可以控制并发线程数。

##### 优缺点

优点：
缺点：